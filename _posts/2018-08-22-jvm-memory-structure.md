---
layout:       post
title:        "JVM内存结构"
subtitle:     "详解Java虚拟机运行时内存结构"
date:         2018-08-22 22:42:05
author:       "Hyuga"
header-img:   "img/2018-08-22/head-top.jpg"
header-mask:  0.3
catalog:      true
multilingual: false
tags:
    - god road
---

之前JVM简介文章中介绍到JVM内存划分有三部分，分别是：
- 类装载：`在JVM启动时或者在类运行时将需要的class加载到JVM`
- 运行时数据区：`JVM中数据交互内存区域`
- 执行引擎：`负责执行class文件中包含的字节码指令`

**本篇主要详解JVM运行时数据区的内存结构**

## Java程序执行过程
  Java 源代码文件（.Java文件）-> Java Compiler（Java编译器）->Java 字节码文件（.class文件）->类加载器（Class Loader）-> Runtime Data Area（运行时数据）-> Execution Engine（执行引擎）

## JVM运行时内存结构
![](/img/2018-08-22/jvm运行时数据区.png)
![](/img/2018-08-22/jvm运行时数据区详细.png)

`线程私有`：程序计数器、java栈、本地方法栈

`线程共享`：堆、方法区

程序计数器 `线程私有`
- 记录当前线程执行的字节码的行号。
- 线程私有的，每条线程都对应一个独立的程序计数器。
- 一个很小的内存空间，是内存结构中唯一一个不会抛出OOM的内存区域。

Java虚拟机栈 `线程私有`
- 虚拟机会为每个线程分配一个虚拟机栈，每个虚拟机栈中都有若干个栈帧，每个栈帧中存储了`局部变量表`、`操作数栈`、`动态链接`、`返回地址`等。一个栈帧就对应Java代码中的一个方法，当线程执行到一个方法时，就代表这个方法对应的栈帧已经进入虚拟机栈并且处于栈顶的位置，每一个Java方法从被调用到执行结束，就对应了一个栈帧从入栈到出栈的过程。
- 在Java中的方法开始运行时创建，随着方法执行结束而结束，生命周期等同于方法执行周期
    - 内存不足时会抛出OOM（内存溢出）
    - 当产生的栈深度超过了允许的栈深度时抛出StackOverFlowError（堆栈溢出），比如无限递归。

本地方法栈 `线程私有`
- 和虚拟机栈类似，只不过调用的方法是Native方法。
- 线程私有，生命周期与线程相同。

Java堆 `线程共享`
- 内存结构中占据空间最大的一部分内存结构。主要用于存储new出来的实例对象和数组。也是垃圾收集器的主要执行目标区域，当Java堆内存不够时会首先启动垃圾收集器清理无用对象。当GC过后内存还是不够就会抛出OOM。

方法区 `线程共享`
- 主要用于存储虚拟机加载的类信息、常量、静态变量、类的字段和方法、类的访问权限、类名以及编译器编译后的代码等数据。
- 方法区的大小决定了系统可以保存多少个类。
- 方法区的大小设置
    - JDK1.8前：
        - 方法区是堆的一个“逻辑部分”（一片连续的堆空间），但为了与堆做区分，方法区还有个名字叫“非堆”，也有人用“永久代”（HotSpot对方法区的实现方法）来表示方法区。
        - 可以通过-XX:PermSize 和 -XX:MaxPermSize 参数限制方法区的大小。【这是jdk1.8以前的永久代设置方式】
        - 方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。【这是jdk1.8以前的永久代可能抛出的异常】
        - 存在两种异常：StackOverFlowError和OutOfMemoryError。
    - JDK1.8开始：
        - 元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制，但可以通过以下参数来指定元空间的大小：
        - -XX:MetaspaceSize：设置元空间初始空间大小，达到该值就会触发垃圾收集进行类型卸载，同时GC会对该值进行调整：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过MaxMetaspaceSize时，适当提高该值。
        - -XX:MaxMetaspaceSize，最大空间，默认是没有限制的。
        - -XX:MinMetaspaceFreeRatio，在GC之后，最小的Metaspace剩余空间容量的百分比，减少为分配空间所导致的垃圾收集
        - -XX:MaxMetaspaceFreeRatio，在GC之后，最大的Metaspace剩余空间容量的百分比，减少为释放空间所导致的垃圾收集
- 方法区存储的大致内容如下:
    - 每一个类的结构信息
    - 运行时常量池（Runtime Constant Pool）
    - 字段和方法数据
    - 构造函数和普通方法的字节码内容
    - 类、实例、接口初始化时用到的特殊方法

方法区中有个运行时常量池，用于存放编译期间生成的各种字面量和符号引用，这部分内容在类加载后进入方法区的运行时常量池中。

Java中的几种常量池后续篇章再总结