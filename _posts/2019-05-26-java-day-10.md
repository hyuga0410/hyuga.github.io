---
layout:       post
title:        "JAVA-DIY-10-WEEK"
subtitle:     "Persistence is not necessarily successful, but not sure will not succeed."
date:         2019-05-26 20:42:05
author:       "Hyuga"
header-img:   "img/cover/head-top-28.jpg"
header-mask:  0.3
catalog:      true
multilingual: false
tags:
    - java-diy
---

## 第7次讨论主题：集合转数组

#### ArrayList.toArray()推荐有参数，还是无参数，为什么？
> 推荐有参数的`public <T> T[] toArray(T[] a)`

{% highlight java %}
ArrayList<Integer> arrayList = new ArrayList<>();

Object[] objects = arrayList.toArray();

Integer[] integers = arrayList.toArray(new Integer[2]);
{% endhighlight %}


单从返回结果看，无参返回的是`Object[]`，如果只是拿来打印输出的话倒也没什么所谓，但如果是要对返回结果进行操作，则需要进行类型转换，手动类型转换，可能出现类型转换异常问题。从这一点考虑，有参返回更安全。

**详解**

`Arrays.copyOf(elementData, size);`和`(T[]) Arrays.copyOf(elementData, size, a.getClass());`

其实都是调用了以下方法！

{% highlight java %}
public static <T,U> T[] copyOf(U[] original, int newLength, Class<? extends T[]> newType) {
    @SuppressWarnings("unchecked")
    T[] copy = ((Object)newType == (Object)Object[].class)
        ? (T[]) new Object[newLength]
        : (T[]) Array.newInstance(newType.getComponentType(), newLength);
    System.arraycopy(original, 0, copy, 0,
                     Math.min(original.length, newLength));
    return copy;
}
{% endhighlight %}

copyOf方法创建了一个新的T[]数组，类型为原集合类型或参数数组类型，在调用System.arraycopy进行拷贝。
无参方法直接根据原集合类型创建一个新的Object[]对象调用System.arraycopy进行拷贝。
有参方法根据参数数组类型，通过数组反射生成一个新的T[]数组对象调用System.arraycopy进行拷贝。

当使用有参方法时，如果参数数组类型和最终接收的数组类型不同，会报编译错误。

如下代码：
{% highlight java %}
ArrayList<Integer> arrayList = new ArrayList<>();
Integer[] integers = arrayList.toArray(new String[0]);
{% endhighlight %}