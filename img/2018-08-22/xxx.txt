---
layout:       post
title:        "JVM内存结构"
subtitle:     "详解Java虚拟机运行时内存结构"
date:         2018-08-22 22:42:05
author:       "Hyuga"
header-img:   "img/2018-08-22/head-top.jpeg"
header-mask:  0.3
catalog:      true
multilingual: false
tags:
    - god road
---

之前JVM简介文章中介绍到JVM内存划分有三部分，分别是：
- 类装载：`在JVM启动时或者在类运行时将需要的class加载到JVM`
- 运行时数据区：`JVM中数据交互内存区域`
- 执行引擎：`负责执行class文件中包含的字节码指令`

**本篇主要详解JVM运行时数据区的内存结构**

## Java程序执行过程
  Java 源代码文件（.Java文件）-> Java Compiler（Java编译器）->Java 字节码文件（.class文件）->类加载器（Class Loader）-> Runtime Data Area（运行时数据）-> Execution Engine（执行引擎）

---

## JVM运行时内存结构
![](/img/2018-08-22/jvm运行时数据区.png)
![](/img/2018-08-22/jvm运行时数据区详细.png)

程序计数器 `线程私有`
- 记录当前线程执行的字节码的行号。
- 线程私有的，每条线程都对应一个独立的程序计数器。
- 一个很小的内存空间，是内存结构中唯一一个不会抛出OOM的内存区域。
Java虚拟机栈 `线程私有`
- 在Java中的方法开始运行时创建，随着方法执行结束而结束，因此生命周期等同于方法执行周期，包括局部变量、操作数栈、动态链接、返回地址等。内存不足时会抛出OOM，当产生的栈深度超过了允许的栈深度时抛出StackOverFlowError，比如无限递归。
本地方法栈 线程私有
- 和虚拟机栈类似，只不过调用的方法是Native方法。
- 线程私有，生命周期与线程相同。
Java堆 线程共享
- 内存结构中占据空间最大的一部分内存结构。主要用于存储new出来的实例对象和数组。也是垃圾收集器的主要执行目标区域，当Java堆内存不够时会首先启动垃圾收集器清理无用对象。当GC过后内存还是不够就会抛出OOM。
方法区 线程共享
- 线程共享区域。
- 主要用于存储虚拟机加载的类信息、常量、静态变量、类的字段和方法、类的访问权限、类名以及编译器编译后的代码等数据。
- 方法区的大小决定了系统可以保存多少个类。
- 方法区的大小设置
    - JDK1.8前：
        - 方法区是堆的一个“逻辑部分”（一片连续的堆空间），但为了与堆做区分，方法区还有个名字叫“非堆”，也有人用“永久代”（HotSpot对方法区的实现方法）来表示方法区。
        - 可以通过-XX:PermSize 和 -XX:MaxPermSize 参数限制方法区的大小。【这是jdk1.8以前的永久代设置方式】
        - 方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。【这是jdk1.8以前的永久代可能抛出的异常】
        - 存在两种异常：StackOverFlowError和OutOfMemoryError。
    - JDK1.8开始：
        - 元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制，但可以通过以下参数来指定元空间的大小：
        - -XX:MetaspaceSize：设置元空间初始空间大小，达到该值就会触发垃圾收集进行类型卸载，同时GC会对该值进行调整：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过MaxMetaspaceSize时，适当提高该值。
        - -XX:MaxMetaspaceSize，最大空间，默认是没有限制的。
        - -XX:MinMetaspaceFreeRatio，在GC之后，最小的Metaspace剩余空间容量的百分比，减少为分配空间所导致的垃圾收集
        - -XX:MaxMetaspaceFreeRatio，在GC之后，最大的Metaspace剩余空间容量的百分比，减少为释放空间所导致的垃圾收集
- 方法区存储的大致内容如下:
    - 每一个类的结构信息
    - 运行时常量池（Runtime Constant Pool）
    - 字段和方法数据
    - 构造函数和普通方法的字节码内容
    - 类、实例、接口初始化时用到的特殊方法

问题：
1.方法区里面存class文件信息和class文件常量池是个什么关系
2.class文件常量池和运行时常量池是什么关系
详见印象笔记Hollis-jVM的《方法区和常量池》

---
虚拟机栈

虚拟机会为每个线程分配一个虚拟机栈，每个虚拟机栈中都有若干个栈帧，每个栈帧中存储了局部变量表、操作数栈、动态链接、返回地址等。一个栈帧就对应Java代码中的一个方法，当线程执行到一个方法时，就代表这个方法对应的栈帧已经进入虚拟机栈并且处于栈顶的位置，每一个Java方法从被调用到执行结束，就对应了一个栈帧从入栈到出栈的过程。

--
运行时常量池 线程共享
  ● 是方法区的一部分，class文件除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译期间生成的各种字面量和符号引用，这部分内容在类加载后进入方法区的运行时常量池中。
  ● 运行时常量池相对于class文件常量池的另一个重要特性就是具备动态性，java语言并不要求常量一定只有编译期才能产生，也就是并非预置入class文件中的常量池内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用的比较多的便是String类的intern()方法。
  ● 当常量池无法再申请到内存时会抛出OutOfMemoryError异常。
直接内存
  ● 直接内存（Direct Memory）不是虚拟机运行时数据的一部分，也不是java虚拟机规范中定义的内存区域。它是利用本地方法库直接在Java堆之外申请的内存区域。
  ● 但是这部分内存被频繁的调用可能会导致OutOfMemoryError异常出现。
  ● 本机直接内存的分配不会受到java堆大小的限制。
  ● 例如：在JDK1.4中新加入了NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/0方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。
--------------------------------------------------------------------------------
栈和堆的区别
功能不同
  ● 从软件设计的角度看，JVM栈代表了处理逻辑，而JVM堆代表了数据。
  ● 栈内存用来存储局部变量和方法调用。
  ● JVM栈中，一个对象只对应了一个4byte的引用。
  ● 栈是运行时的单位
  ● 堆内存用来存储Java中的对象。无论是成员变量，局部变量，还是类变量，它们指向的对象都存储在堆内存中。
  ● JVM堆是存储的单位，存的是对象。
  ● JVM堆内容可以被多个JVM栈共享（多线程访问同个对象）。共享内存，共享常量和缓存。
共享性不同
  ● 栈内存是线程私有的，每个Java线程拥有自己的独立的JVM栈，也就是Java方法的调用栈。每个Java线程拥有自己的独立的native方法栈。
  ● 堆内存是所有线程共有的，所有线程共享堆内存。
异常错误不同
  ● 如果栈内存或者堆内存不足都会抛出异常。
      ○ 栈空间不足：java.lang.StackOverFlowError。
      ○ 堆空间不足：java.lang.OutOfMemoryError。
空间大小
  ● 栈的空间大小远远小于堆的。
--------------------------------------------------------------------------------
栈
什么是Java虚拟机栈
栈我们可以想象成一本一本书叠起来，后进先出。

栈是jvm分配的一块内存，由栈帧组成，每当线程调用一个java方法时，JVM就会在该线程对应的栈中压入一个帧，而帧是由`局部变量区`、`操作数栈`和`帧数据区`组成。

栈的组成【深入理解栈】
栈帧由三部分组成：`局部变量表`、`操作数栈`、`帧数据区`。

栈的数据结构
一个线程一个栈（栈帧结构数组），一个函数一个栈帧，每个栈帧有个变量表、操作数栈、帧数据区（栈数据数组）
变量表：函数变量
操作数栈：函数变量数据操作iinc等指令操作
帧数据区：一个栈结构数组，存储函数变量值

单函数单栈帧：
将数值1入栈帧数据区栈顶
将栈顶值赋给变量i
单栈帧内入栈出栈发生在帧数据区，iconst（变量常量入栈）、istore（变量常量赋值）
iinc等指令发生在操作数栈中，最终处理完的值有没有赋值给变量是由指令决定的
多函数嵌套多栈帧：
每个嵌套函数都在调用函数栈的后面追加新的栈帧，栈帧链条形成后，根据栈的特性后进先出，对末尾栈帧进行变量值运算，并根据指令进行压栈操作，将栈帧联调压缩进而得到最终调用函数栈的值。
局部变量表和操作数栈的大小要视对应的方法而定，他们是按字长计算的。但调用一个方法时，它从类型信息中得到此方法局部变量区和操作数栈大小，并据此分配栈内存，然后压入Java栈。
  ● 栈的特性：“后入先出”（LIFO）
      ○ 函数调用的局部状态用栈记录，是因为这些数据的存活时间满足LIFO顺序。函数顺序嵌套，被调用者的局部信息所占空间的分配总是后于调用者的（后入），而其释放则总是先于调用者的（先出），所以正好可以满足栈的LIFO顺序，选用栈这种数据结构来实现调用栈是一种很自然的选择。
--------------------------------------------------------------------------------
局部变量表
局部变量表存放了基本数据类型、对象引用和return Address类型（指向一条字节码指令的地址）。
其中64位长度的long和double类型的数据会占用2个局部变量空间（slot[槽]）【在访问局部变量中的long或double时，只需取出连续两项的第一项的索引值即可】，其余数据类型只占用1个。
  1. public class StackDemo {
  2.     //静态方法
  3.     public static int runStatic(int i, long l, float f, Object o, byte b) {
  4.         return 0;
  5.     }
  6.     //实例方法
  7.     public int runInstance(char c, short s, boolean b) {
  8.         return 0;
  9.     }
  10. }


局部变量表所需的内存空间在编译期间完成分配。
每个方法都对应一个栈帧。
--------------------------------------------------------------------------------
操作数栈
  ● Java没有寄存器，所有参数传递都是使用操作数栈。
  ● 操作数栈其实就是个临时数据存储区域，它是通过入栈和出栈来进行操作的。
  1. public static int add(int a,int b){
  2.     int c=0;
  3.     c=a+b;
  4.     return c;
  5. }
压栈的步骤如下：
0:   iconst_0 // 0压栈
1:   istore_2 // 弹出int，存放于局部变量2
2:   iload_0  // 把局部变量0压栈
3:   iload_1 // 局部变量1压栈
4:   iadd      //弹出2个变量，求和，结果压栈
5:   istore_2 //弹出结果，放于局部变量2
6:   iload_2  //局部变量2压栈
7:   ireturn   //返回

如果计算100+98的值，那么操作数栈的变化如下图所示：

--------------------------------------------------------------------------------
帧数据区
除了局部变量区和操作数栈外，java栈帧还需要一些数据来支持常量池解析、正常方法返回以及异常派发机制。这些数据都保存在java栈帧的帧数据区中。
当JVM执行到需要常量池数据的指令时，它都会通过帧数据区中指向常量池的指针来访问它。
除了处理常量池解析外，帧里的数据还要处理java方法的正常结束和异常终止。如果是通过return正常结束，则当前栈帧从Java栈中弹出，恢复发起调用的方法的栈。如果方法有返回值，JVM会把返回值压入到发起调用方法的操作数栈。
为了处理java方法中的异常情况，帧数据区还必须保存一个对此方法异常引用表的引用。当异常抛出时，JVM给catch块中的代码。如果没发现，方法立即终止，然后JVM用帧区数据的信息恢复发起调用的方法的帧。然后再发起调用方法的上下文重新抛出同样的异常。
--------------------------------------------------------------------------------
栈上分配(动态链连接)
小对象（一般几十个bytes），在没有逃逸(外部调用)的情况下，可以直接分配在栈上。
直接分配在栈上，可以自动回收，减轻GC压力。
大对象或者逃逸对象无法栈上分配。

--------------------------------------------------------------------------------
方法的返回地址
每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。我们知道Class文件的常量池有存有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用为参数。这些符号引用一部分会在类加载阶段或第一次使用的时候转化为直接引用，这种转化称为静态解析。另外一部分将在每一次的运行期间转化为直接引用，这部分称为动态连接。

当一个方法被执行后，有两种方式退出这个方法。第一种方式是执行引擎遇到任意一个方法返回的字节码指令，这时候可能会有返回值传递给上层的方法调用者（调用当前方法的方法称为调用者），是否有返回值和返回值的类型将根据遇到何种方法返回指令来决定，这种退出方法的方式称为正常完成出口（Normal Method Invocation Completion）。
另外一种退出方式是，在方法执行过程中遇到了异常，并且这个异常没有在方法体内得到处理，无论是Java虚拟机内部产生的异常，还是代码中使用athrow字节码指令产生的异常，只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，这种退出方法的方式称为异常完成出口（Abrupt Method Invocation Completion）。一个方法使用异常完成出口的方式退出，是不会给它的上层调用者产生任何返回值的。
无论采用何种退出方式，在方法退出之后，都需要返回到方法被调用的位置，程序才能继续执行，方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层方法的执行状态。一般来说，方法正常退出时，调用者的PC计数器的值就可以作为返回地址，栈帧中很可能会保存这个计数器值。而方法异常退出时，返回地址是要通过异常处理器来确定的，栈帧中一般不会保存这部分信息。
方法退出的过程实际上等同于把当前栈帧出栈，因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值（如果有的话）压入调用者栈帧的操作数栈中，调整PC计数器的值以指向方法调用指令后面的一条指令等。
--------------------------------------------------------------------------------
附加信息
虚拟机规范允许具体的虚拟机实现增加一些规范里没有描述的信息到栈帧之中，例如与调试相关的信息，这部分信息完全取决于具体的虚拟机实现，这里不再详述。在实际开发中，一般会把动态连接、方法返回地址与其他附加信息全部归为一类，称为栈帧信息。

--------------------------------------------------------------------------------
栈的整个结构
栈是由栈帧组成，每当线程调用一个java方法时，JVM就会在该线程对应的栈中压入一个帧，而帧是由局部变量区、操作数栈和帧数据区组成。
那在一个代码块中，栈到底是什么形式呢？下面是我从《深入JVM》中摘抄的一个例子，大家可以看看：
  1. public class Main{
  2.     public static void addAndPrint(){
  3.         double result = addTwoTypes(1,88.88);
  4.         System.out.println(result);
  5.     }
  6.     public static double addTwoTypes(int i,double d){
  7.         return i + d;
  8.     }
  9. }
执行过程中的三个快照：

  1. 只有在调用一个方法时，才为当前栈分配一个帧，然后将该帧压入栈
  2. 帧中存储了对应方法的局部数据，方法执行完，对应的帧则从栈中弹出，并把返回结果存储在调用 方法的帧的操作数栈中
--------------------------------------------------------------------------------
堆
堆在Java虚拟机启动时候被创建，它存储着Java中的对象，包含：成员变量，局部变量，类变量。
堆被同一个JVM实例中的所有Java线程共享，堆空间不足：java.lang.OutOfMemoryError。
堆我们可以想象成一个储藏室，里面的物品随意摆放，或者想象成垃圾场。
堆分为`堆内内存`和`堆外内存`:
1. 在使用堆内内存时候完全遵守JVM虚拟机的内存管理机制，也就是GC统一管理;
2. 堆外内存就是把内存分配在Java虚拟机之外，这些内存OS直接管理，我们经常用java.nio.DirectByteBuffer对象进行堆外内存的管理和使用，堆外内存优点：减少回收，加快复制，堆外内存的缺点就是内存难以控制。

  1. 存储的全部是对象实例，每个对象都包含一个与之对应的class的信息(class信息存放在方法区)。
  2. jvm只有一个堆区(heap)被所有线程共享，堆中不存放基本类型和对象引用，只存放对象本身，几乎所有的对象实例和数组都在堆中分配。
--------------------------------------------------------------------------------
堆内内存
堆内内存是我们平常工作中接触比较多的，在jvm参数中只要使用-Xms，-Xmx等参数就可以设置堆的大小和最大值，理解jvm的堆还需要知道下面这个公式：
堆内内存 = 新生代+老年代+持久代


在使用堆内内存（on-heap memory）的时候，完全遵守JVM虚拟机的内存管理机制，采用垃圾回收器（GC）统一进行内存管理，GC会在某些特定的时间点进行一次彻底回收，也就是Full GC，GC会对所有分配的堆内内存进行扫描，在这个过程中会对JAVA应用程序的性能造成一定影响，还可能会产生Stop The World。
常见的垃圾回收算法主要有：
  ● 引用计数器法（Reference Counting）
  ● 标记清除法（Mark-Sweep）
  ● 复制算法（Coping）
  ● 标记压缩法（Mark-Compact）
  ● 分代算法（Generational Collecting）
  ● 分区算法（Region）
注：在这里我们不对各个算法进行深入介绍，感兴趣的同学可以关注我的下一篇关于垃圾回收算法的介绍分享。
--------------------------------------------------------------------------------
堆外内存
堆外内存就是把内存对象分配在Java虚拟机的堆以外的内存，这些内存直接受操作系统管理（而不是虚拟机），这样做的结果就是能够在一定程度上减少垃圾回收对应用程序造成的影响。
作为JAVA开发者我们经常用java.nio.DirectByteBuffer对象进行堆外内存的管理和使用，它会在对象创建的时候就分配堆外内存。
DirectByteBuffer类是在Java Heap外分配内存，对堆外内存的申请主要是通过成员变量unsafe来操作。
使用堆外内存的优点
  ● 减少了垃圾回收
      ○ 因为垃圾回收会暂停其他的工作。
  ● 加快了复制的速度
      ○ 堆内在flush到远程时，会先复制到直接内存（非堆内存），然后在发送；而堆外内存相当于省略掉了这个工作。
堆外内存的缺点
  ● 内存难以控制，使用了堆外内存就间接失去了JVM管理内存的可行性，改由自己来管理，当发生内存溢出时排查起来非常困难。
--------------------------------------------------------------------------------
方法区
  ● 全局共享的一块内存区域，存储着Java类结构信息：常量、静态变量、以及类中声明的方法，方法字段等等。
  ● 又叫静态区，跟堆一样，被所有的线程共享。它用于存储已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。
  ● 方法区在HotSpot中又被称为永久代。
  ● 该区域的回收目标主要是对常量池的回收以及类的卸载。
  ● 当内存空间不足时，无法为方法区开辟新空间时，将抛出OutOfMemoryError。
  ● 运行时常量池，存储类加载后的常量池信息。JVM在执行某个类的时候，必须经过加载、连接、初始化，而连接又包括验证、准备、解析三个阶段。而当类加载到内存中后，jvm就会将class常量池中的内容存放到运行时常量池中。
--------------------------------------------------------------------------------
常见误区
一、Java中的基本数据类型一定存储在栈中吗？
不一定。栈内存用来存储局部变量和方法调用。
如果该局部变量是基本数据类型例如

  1. int a = 1;
那么直接将该值存储在栈中。
如果该局部变量是一个对象如

  1. int[] array=new int[]{1,2};
那么将引用存在栈中而对象({1,2})存储在堆内。

二、栈的速度比堆快吗？
一定情况下栈的速度是比堆快的，但是快的并不明显。毕竟都是RAM。所以这算不上堆和栈的一大区别。


结论
基本类型数据如果是局部变量并且非对象那么JVM中是把值直接存入栈中的，而不是存储一个引用对象然后借由这个对象来找到值。
这其实算的上是实际运行时JVM提供的性能优化。



---
OOM
  ● OOM，全称“Out Of Memory”
  ● 为什么会OOM？
      ○ 分配的少了：比如虚拟机本身可使用的内存（一般通过启动时的VM参数指定）太少。
      ○ 应用用的太多，并且用完没释放，浪费了。此时就会造成内存泄露或者内存溢出。
  ● 内存泄漏和内存溢出
      ○ 内存泄露：申请使用完的内存没有释放，导致虚拟机不能再次使用该内存，此时这段内存就泄露了，因为申请者不用了，而又不能被虚拟机分配给别人用。
      ○ 内存溢出：申请的内存超出了JVM能提供的内存大小，此时称之为溢出。
---
## 参考资料:
**《深入理解Java虚拟机》**

   链接：[Java虚拟机的内存组成以及堆内存介绍-HollisChuang's Blog][1]

   链接：[Java堆和栈看这篇就够 - Johnny-Zhuang's Technology Blog][2]

   链接：[Java虚拟机的堆、栈、堆栈如何去理解？ - 知乎][3]

   链接：[Java 内存之方法区和运行时常量池 - 漠然的博客 | mritd Blog][4]

   链接：[从0到1起步-跟我进入堆外内存的奇妙世界 - 简书][5]


   [1]:http://www.hollischuang.com/archives/80
   [2]:https://iamjohnnyzhuang.github.io/java/2016/07/12/Java%E5%A0%86%E5%92%8C%E6%A0%88%E7%9C%8B%E8%BF%99%E7%AF%87%E5%B0%B1%E5%A4%9F.html
   [3]:https://www.zhihu.com/question/29833675
   [4]:https://mritd.me/2016/03/22/Java-%E5%86%85%E5%AD%98%E4%B9%8B%E6%96%B9%E6%B3%95%E5%8C%BA%E5%92%8C%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0/
   [5]:https://www.jianshu.com/p/50be08b54bee

   [6]:https://baike.baidu.com/item/JVM/2902369?fr=aladdin